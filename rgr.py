# -*- coding: utf-8 -*-
"""RGR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fGmUqERtrxGeqjx1uvONeAD3k4KtvvN8
"""

!unzip /content/logo.zip # Распаковка архива
# Импортируем модули
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os

# Пути к данным
logo_path = os.listdir('/content/logo')
logo_types = os.listdir('/content/logo')
print (logo_types)
print("найдено категорий: ", len(logo_path))

# Сортировка по категориям
logo_path.sort()
logo_path

logo_types.sort()
logo_types

# Задаем весовые коэффициенты категорий данных для компенсации несбалансированности
# имеем 999 ложных подписей и 100 своих, поэтому
class_weight = {0: 999/100, 1: 1}
# Преобразуем изображения
import cv2
path = '/content/logo'

im_size = 256          #ЗАДАТЬ размер изображения!!!

images = []
labels = []

images = []
labels = []

for i in logo_types:
    data_path = path + str(i)  # entered in folder
    filenames = [i for i in os.listdir(data_path) if i.endswith('.png')]
    #print(filenames)  # will get the names of all images which ends with .jpg extension
    for f in filenames:
        img = cv2.imread(data_path + '/' + f)  # reading that image as array
        #print(img)  # will get the image as an array
        img = cv2.resize(img, (im_size, im_size))
        images.append(img)
        labels.append(i)

labels
# Transform the image array to a numpy type
images = np.array(images)
images.shape

images = images.astype('float32') / 255.0

label_dummies = pd.get_dummies(labels)
label_dummies
# Extract the labels
labels =  label_dummies.values.argmax(1)
labels

pd.unique(labels)

from sklearn.model_selection import train_test_split

test_size =  256             #ЗАДАТЬ размер тестового изображения!!!
X_train, X_test, y_train, y_test = train_test_split(images, labels, shuffle=True, test_size=test_size)

width = im_size
height = im_size
# Определяем модель сети
import keras
from keras import models
from keras import layers
from tensorflow.keras.utils import plot_model

model = models.Sequential()
model.add(layers.Conv2D(32,(3,3), activation ='relu', input_shape=(256,256,3)))
model.add(layers.MaxPool2D((2,2)))
model.add(layers.Conv2D(64,(3,3), activation ='relu'))
model.add(layers.MaxPool2D((2,2)))
model.add(layers.Conv2D(64,(3,3), activation ='relu'))
model.add(layers.Flatten())
model.add(layers.Dense(64, activation ='relu'))
model.add(layers.Dense(10, activation ='softmax'))
model.summary()


plot_model(model, to_file = 'model_plot.png', show_shapes = True, show_layer_names = False)
# Компилируем модель
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])
# Обучаем
batch_size = 32         #ЗАДАТЬ размер пакета!!!
epochs = 10            #ЗАДАТЬ количество эпох!!!
history = model.fit(X_train, y_train, batch_size=batch_size, epochs=epochs, class_weight=class_weight, validation_data = (X_test,y_test))
# График потерь
loss = history.history['loss']
val_loss = history.history['val_loss']
epochs = range(1, len(loss) + 1)
plt.plot(epochs, loss, 'b--',epochs, val_loss, 'r' )
plt.show()
# График точности
acc = history.history['accuracy']
val_acc = history.history['val_accuracy']
epochs = range(1, len(loss) + 1)
plt.plot(epochs, acc, 'b--',epochs, val_acc, 'r' )
plt.show()
# Сохранить модель и скачать
mp = "logo_model.h5"
model.save(mp)

# Импортировать модули
import numpy as np
import pandas as pd
import matplotlib.image as mpimg
import matplotlib.pyplot as plt
import os
import cv2

# Загружаем модель сети
import keras
from keras import models
from keras.models import load_model
model = load_model('logo_model.h5')

# Загружаем тестовый рисунок test.jpg в файловую систему
image = mpimg.imread('/content/test.png')
implot = plt.imshow(image)

# Преобразуем изображение
im_size = 256
width = im_size
height = im_size

test = cv2.imread("/content/test.png")
test = cv2.resize(test, (im_size, im_size))
test = test.astype('float32') / 255.0

# Выполняем распознавание
pred = model.predict(np.expand_dims(test, axis=0))
pred

# Определяем категорию
classes = np.argmax(pred, axis=1)
classes
if classes == 0:
  print("Подпись моя!")
else:
  print("Подпись не моя!")

image = mpimg.imread('/content/signature (9).png')
implot = plt.imshow(image)

im_size = 256
width = im_size
height = im_size

test = cv2.imread("/content/signature (9).png")
test = cv2.resize(test, (im_size, im_size))
test = test.astype('float32') / 255.0

# Выполняем распознавание
pred = model.predict(np.expand_dims(test, axis=0))
pred

# Определяем категорию
classes = np.argmax(pred, axis=1)
classes
if classes == 0:
  print("Подпись моя!")
else:
  print("Подпись не моя!")